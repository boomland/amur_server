# Цель проекта

Доводилось ли вам иметь дело с современными сайтами знакомств, такими как Tinder, Badoo, Hotornot?
К сожалению, на текущий момент подобные сервисы будут подбирать вашу вторую половинку только исходя
из её местоположения, пола, возраста, а также группы других эвристических параметров.


Нашей целью являлось создание собственного сервиса, являющегося рекомендательной системой для уже
существующих. Рекомендательную систему, которая будет способна обучаться индивидуальным предпочтениям
людей о внешности своей второй половинки и осуществлять фильтрацию выдачи.

# Серверная часть

## Компиляция
Серверная часть проекта была выполнена на языке С++. Компиляция кода тестировалась на следующих
платформах:
  - Ubuntu 16.04 (gcc)
  - Windows 10 (Visual Studio 2015)

Для построения проекта вам потребуются следующие библиотеки:
  - boost 1.60.0
  - MySQL C++ connector (для доступа к базе данных)
  - [cpp-netlib](https://github.com/cpp-netlib/cpp-netlib) (для организации работы с http протоколом)
  - curl
  - [curlpp](https://github.com/datacratic/curlpp)
  - [nanoflann](https://github.com/jlblancoc/nanoflann) (kd-trees)
  - [JSON](https://github.com/nlohmann/json) (для работы c json) 
  - dlib
  - CUDA Drivers (для выполнения расчетов на GPU)
  
Так же, вам потребуется MySQL Server.

Для запуска подчасти сервера - сервера расчета дескрипторов лиц - потребуется следующее:
  - Python 3.x
  - Tensorflow + Keras
  - Библиотека [keras-vggface](https://github.com/rcmalli/keras-vggface)

В случае отсутствия статичного IP и/или возможности организации доступа к вашей машине извне по желаемому порту,
реализация сервера предусматривает работу с сервисом создания динамических туннелей [ngrok](https://ngrok.io). Если вы 
хотите использовать его, в файле config.ini установите соответствующие параметры.

Кроме того, в зависимости от настроек сервера, может потребоваться значительное количество оперативной и GPU
памяти! Стандартная конфигурация сервера требует в пиковые моменты нагрузки порядка 4GB оперативной и 4GB
GPU памяти. Однако, этого можно избежать(об этом далее).

## API

Сервер работает по протоколу HTTP принимая POST запросы в формате JSON и отвечая тоже в формате JSON.
Порт можно настроить в конфигурационном файле, разделе main, поле "http_port". 
Каждый запрос, осуществляемый к серверу должен сопровождаться базовыми полями:
- tinder_id -- ID клиента, от имени которого совершать действия
- tinder_auth_token -- Токен клиента, сообщенный сервисом Tinder при авторизации
- action -- вид действия, который клиент хочет совершить

Ответ всегда приходит в следующем формате:
- status: "ok"/"error"
- data (в случае успешно выполненного действия) здесь окажется содержательная часть ответа сервера
- error_description (в случае ошибки) -- текстовое описание произошедшей ошибки
-- error_code(в случае ошибки) -- числовой код произошедшей ошибки

Возможный перечень ошибок и их числовых кодов:


|error_name           |error_code|error_description                             |
|---------------------|----------|----------------------------------------------|
|RE_INTERNAL          |300       |Internal server error                         |
|RE_MYSQL_ERROR       |301	     |Internal MySQL query error                    |
|RE_JSON_SYNTAX	      |400	     |Incorrect JSON syntax                         |
|RE_NO_ACTION	        |401	     |No action defined in query                    |
|RE_ACTION_UNKNOWN	  |402	     |Action in query unknown                       |
|RE_MISSED_ARGS	      |403	     |Some arguments in query are absent            |
|RE_INCORRECT_TOKEN	  |501	     |Incorrect token specified in query            |
|RE_NO_AUTH	          |502	     |Client doesn`t authorized on Amur server      |
|RE_TINDER_INTERNAL	  |600	     |Tinder responsed internal error               |
|RE_TINDER_ACTION_FAIL|601	     |Tinder action failed                          |
|RE_TINDER_JSON_SYNTAX|602	     |Tinder response syntax error                  |
|RE_TINDER_RESP_FORMAT|603	     |Tinder response don`t correspond expectations |

На данный момент поддерживаются следующие действия:
- SET_AUTH_TOKEN -- Авторизация на сервере. В ответ сервер должен вернуть информацию о профиле человека в tinder.
- MAKE_VOTE -- запрос на сохранение оценок пользователей. Информация должна быть передана в виде массива в поле 
votes_data, где каждый элемент должен содержать поля id и vote(0/1)
- GET_RECS -- возвращает перечень людей, рекомендуемых пользователю

Подробнее про API можно прочитать [здесь](http://dating-ml.ru/api.html)

## Принцип работы

![Amur server diagram](https://imgur.com/download/bPi7UV3)

1. Внешнее соединения по порту http_port слушает отдельный поток. Каждый пришедший запрос обрабатывается следующим образом:
создается задача для API Worker-ов, которая ложится в API Work pool. Затем происходит пассивное ожидание 
завершения задачи, и клиенту отправляется ответ.

2. **API Worker Thread & API Worker task pool**. Пул представляет из себя очередь задач. По поступлению запроса на получение
работы от воркера(pop метод) пул либо выдает первую в очереди задачу, либо переходит в режим ожидания поступления новых задач.
Worker, получив задачу приступает к ее выполнению, а по окончанию устанавливает ее статус в завершенный, что приводит к
оповещению ждущего этой задачи потока. Эта концепция используется и на других объектах типа worker-pool. Цель связки
под названием API - обработка http запросов, пришедших от клиента(авторизация, сохранение оценок, выдача новых людей).

3. **HTTP Worker Thread & HTTP task pool**. Отвечают за выполнение емких сетевых операций http в клиентском режиме(обращение к 
tinder, скачивание изображений и т.д.)

4. **GPU Worker**. Умеет выполнять два вида запросов.
  - Детекция лиц при помощи библиотеки dlib (осуществляется нейросетью, вычисления проводятся на GPU).
  - Отправка запроса на рассчет дескрипторов лица(обращение к Face Descriptor Server)
 
5. **Background cache thread**. Выполняет функцию пополнения кэша людей-кандидатов. Для каждого пользователя, находящегося в
онлайне последовательно выполняется следующая цепочка действий
  - Запрос новых людей для выбранного человека у Tinder и сохранение в базе даннных.  (API worker)
  - Скачивание всех фотографий, для людей из ответа Tinder. (HTTP Worker)
  - GPU Worker-ам отправляются запросы на детекцию лиц всех скачанных фотографий.
  - Для тех фотографий, на которых было обнаружено всего одно лицо, отправляется запрос на Face Descriptor Server.
  - Дескрипторы сохраняются в базе данных, по усредненному дескриптору рассчитывается кластер, к которому принадлежит человек,
  а так же усредненный дескриптор сохраняется в оперативной памяти (Global Descriptor Pool)

После выполнения подобных операций, новые кандидаты, для которых эта цепочка прошла успешна, становятся кандидатами для пользователей,
подходящих под возрастную категорию, пол, географическое положение.

6. **Authorized clients pool**. Здесь находятся все пользователи имеющие статус онлайн, т.е. авторизовавшиеся на сервере. 
Каждый объект типа "клиент" сохраняет в себе следующую информацию:
  - Базовая информация о профиле
  - Kd-tree из дескрипторов оцененных человеком
  - Kd-tree из дескрипторов кандидатов

## Работа рекомендательной системы
При поступлении очередного запроса, на выдачу рекомендуемых людей выдаваемый батч набирается благодаря следующим трем видам
рекомендаций:
- Выбор случайного человека из малоизведанного кластера. Цель этого действия состоит в том, чтобы исследовать новые области
пространства дескрипторов
- Выбрать случайный кластер. Затем из выбранного кластера выбрать человека, который входит в top k% понравившихся всем
пользователям. Цель этого действия заключается в создании новых опорных точек для третьего действия, а также подогрева
интереса пользователя(Излишнее количество случайных людей подряд на начальных этапах работы может снизить интерес человека к 
сервису).
- Для того, чтобы понять принцип работы этого действия введем несколько понятий. Будем считать, что каждому кандидату присущ
коэффициент, растущий с шансами этого человека быть "лайкнутым" текущим пользователем. Точки, в которых находятся уже "лайкнутые"
люди имеют значение Intensity, и обратно, в которых "дизлайкнутые" -Intensity. Тогда для каждого неоцененного кандидата посчитаем
сумму, где каждая окружающая точка имеет влияние обратно квадратичное от евклидового расстояния до рассчитываемой точки. В рекомендацию
будем выдавать человека с максимальным подобным коэффициентом. Это нужно для того, чтобы области пространства с наибольшим сгущением
положительных оценок имели наивысшие шансы быть выбранными.

Т.к. размерность пространства достаточно велика, то можно предложить следующий достаточно оптимальный алгоритм для рассчета подобных
величин:

Будем поддерживать температуры всех кандидатов и запоминать их. 

- При поступлении запроса типа like/dislike вставим оцениваемого человека
в дерево оценок, удалим из дерева кандидатов, сделаем Radius Search от этой точки в дереве кандидатов.
Обновим их температуры соответственно расстоянию до оцененного человека и типа оценки.
- При поступлении запроса типа "Получить рекомендацию" выдадим человека с максимальным коэффициентом.
- При поступлении нового кандидата добавим его в дерево кандидатов, сделаем радиус серч от этой точки
в дереве оценок и честно рассчитаем коэффициент для него. 
